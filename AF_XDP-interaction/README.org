#+Title: How to transfer info from XDP-prog to AF_XDP

This BPF-example show how use BTF to create a communication channel
between XDP-prog (running kernel-side) and AF_XDP user-space process.

* AF_XDP documentation

When developing your AF_XDP application, we recommend familiarising
yourself with the core AF_XDP concepts, by reading the kernel
[[https://www.kernel.org/doc/html/latest/networking/af_xdp.html][documentation for AF_XDP]]. And XDP-tools also contain documentation in
[[https://github.com/xdp-project/xdp-tools/blob/master/lib/libxdp/README.org#using-af_xdp-sockets][libxdp for AF_XDP]], explaining how to use the API, and the difference
between the control-path and data-path APIs.

It is particularly important to understand the *four different
ring-queues* which are all Single-Producer Single-Consumer (SPSC)
ring-queues. A set of these four queues are needed *for each queue*
on the network device (netdev).

* Example bind to all queues

Usually AF_XDP examples makes a point out-of forcing end-user to
select a specific queue or channel ID, to show that AF_XDP sockets
operates on a single queue ID.

In this example, default behavior, is to setup AF_XDP sockets for
*ALL* configured queues/channels available, and "listen" for packets
on all of the queues.  This way we can ignore setting up hardware
filters or reducing channels to 1 (as a popular workaround).

This also means memory consumption increase as NIC have more queues
available.  For AF_XDP all the "UMEM" memory is preallocated by
userspace and registered with the kernel.  AF_XDP trade wasting memory
for speedup. Each frame is a full memory-page 4K (4096 bytes).  For
each channel/queue ID program allocates 4096 frames, which takes up
16MB memory per channel.

